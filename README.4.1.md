# Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"

## Обязательная задача 1

Есть скрипт:
```bash
a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
```

Какие значения переменным c,d,e будут присвоены? Почему?

| Переменная  | Значение  | Обоснование  |
|:--|:--|:--|
|`c`   |a+b   | Это не арифметическое выражение, а присвоение значения `"a+b"` переменной c.  |
|`d`   |1+2   | Аналогично, присвоение значения `"$a+$b"`, но с подстановкой `$`.  |
|`e`   |3   | `$((...))` - арифметическое выражение. `e=$(($a+$b))` эквивалентно `e=$((a+b))`.  |


## Обязательная задача 2
На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным (после чего скрипт должен завершиться). В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:
```bash
while ((1==1)
do
	curl https://localhost:4757
	if (($? != 0))
	then
		date >> curl.log
	fi
done
```
Непонятно, как этот скрипт вообще запустился, учитывая отсутствие
закрывающей скобки в `while`, что дает синтаксическую ошибку. Далее,
конструкция `if (($? != 0))` вычисляет выражение `$? != 0`. Если код
возврата ненулевой, то значение этого выражения `0` (истина), а
конструкция `(($? != 0))` вернет `1`, отчего условие не выполнится и в
лог ничего не запишется. Зато запишется в противоположном
случае. Выхода из цикла нет в принципе. Исправим, например, так:


### Ваш скрипт:
```bash
until curl -s https://localhost:4757 > /dev/null
do
    date >> curl.log
    sleep 3
done
```

`curl -s`, чтобы не было лишнего вывода. `sleep`, чтобы не грузить машину зря.

## Обязательная задача 3
Необходимо написать скрипт, который проверяет доступность трёх IP: `192.168.0.1`, `173.194.222.113`, `87.250.250.242` по `80` порту и записывает результат в файл `log`. Проверять доступность необходимо пять раз для каждого узла.

### Ваш скрипт:
```bash
#!/bin/bash

CHECK_ADDR=( 192.168.0.1 173.194.222.113 87.250.250.242 )
CHECK_PORT=80
ATTEMPTS=5

check_connection () {
    return $(nc -zw1 "$1" "$2")
}

for addr in "${CHECK_ADDR[@]}"
do
    for ((i=1; i <= ATTEMPTS ; i++))
    do
	if check_connection $addr $CHECK_PORT; then
            echo $(date) $addr ATTEMPT $i OK >> log
	else
            echo $(date) $addr ATTEMPT $i NOT_OK >> log
	fi
	sleep 1
    done
done
```

## Обязательная задача 4
Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается.

### Ваш скрипт:
```bash
#!/bin/bash

CHECK_ADDR=( 192.168.0.1 173.194.222.113 87.250.250.242 )
CHECK_PORT=80
ATTEMPTS=5

check_connection () {
    return $(nc -zw1 "$1" "$2")
}

while true
do
    for addr in "${CHECK_ADDR[@]}"
    do
		for ((i=1; i <= ATTEMPTS ; i++))
		do
		if check_connection $addr $CHECK_PORT; then
			echo $(date) $addr ATTEMPT $i OK >> log
		else
			echo $(date) $addr ATTEMPT $i NOT_OK >> log
			echo $addr >> error
			exit 1
		fi
	    sleep 1
		done
    done
done
```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Мы хотим, чтобы у нас были красивые сообщения для коммитов в
репозиторий. Для этого нужно написать локальный хук для git, который
будет проверять, что сообщение в коммите содержит код текущего задания
в квадратных скобках и количество символов в сообщении не
превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.



### Ваш скрипт:
```bash
#!/bin/sh

msg=""
while read -r line || [[ -n "$line" ]]; do
    if [[ ${line:0:1} == "#" ]]
    then continue
    fi
    
    msg=$msg$line
done < "$1"

if [[ ${#msg} -gt 30 ]]
then echo >&2 "Message is longer than 30 characters."; exit 1
fi

homework_num=$(expr "$msg" : '\(\[[0-9][0-9]-.*[0-9][0-9]-.*\]\)')

if [[ $homework_num = "" ]]
then
   echo >&2 "Message should start with a homework number. Format: [04-script-01-bash]"; exit 1
fi

exit 0

```

